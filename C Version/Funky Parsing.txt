funky parse_prog {
	make var list {name, expr} -- Not hashmap to preserver order.
	while can find var (sym, op{:=}) {
		parse var into list
	}
	parse expr
	return Prog{vars, expr}
}

funky parse_var {
	get sym as name
	skip token ':='
	parse expr
	skip token ';', if finished with other -> error
	return Var{name, expr}
}

funky parse_expr {
	until find end of expr {
		parse instr
	}
	return Instrs
}

funky parse_instr {
	if token num -> return Num
	if token str -> return Str
	if token sym -> return Sym
	if token normal op -> return Sym{op}
	if token '{' -> return parse funky
	if token '[' -> return parse list
	if token ''' -> return parse refof
	else error
}

funky parse_funky {
	skip token '{'
	find first non sym token
	if is token '->' -> puts syms as params, else -> no params
	parse prog, skipping params if present
	skip token '}', if finished with other -> error
	return Funky{params + prog.vars, prog.body}
}

funky parse_list {
	skip token '['
	while {
		parse expr into list
		skip token ',' or ']', if finished with other -> error
		if skipped token ']' -> break
	}
	if only parsed empty expr, list empty
	skip token ']', if finished with other -> error
	return List
}

funky parse_refof {
	skip token '''
	if next token ''' -> error
	parse instr
	return Funky{[], instr}
}